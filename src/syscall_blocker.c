// filepath: /sys-call-blocker/src/syscall_blocker.bpf.c

#include "syscall_blocker.h"
#include <bpf/bpf.h>
#include <bpf/libbpf.h>
#include <errno.h>
#include <fcntl.h>
#include <seccomp.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <termios.h>
#include <unistd.h>

/* // generated by bpftool in build directory. if not exist, build the project
// to generate it */
#include "syscall_blocker.skel.h"

void print_help(const char *name);
int get_int(const char *s, const char *msg);
unsigned long get_long(const char *s, const char *msg);
void get_string(char *target, char *source);
void display_config(struct Configuration *config);
void set_nonblocking_mode(int enable);
void get_container_info(const char *cgroup_path, char *container_type,
                        char *container_id);
int kill_container_prompt();

// Signal handler function to gracefully stop this program
volatile sig_atomic_t stop = 0;
void handle_signal(int sig) {
  stop = 1; // Set flag to exit loop
}

// handles events from ebpf program
static int handle_event(void *ctx, void *data, size_t len) {
  char container_type[10], container_id[13];
  struct event *e = data;
  char *syscall_name =
      seccomp_syscall_resolve_num_arch(SCMP_ARCH_X86_64, e->syscall_no);
  get_container_info(e->cgroup_path, container_type, container_id);
  printf("Event : Blocked syscall %s initiated by PID %d (%s) - container = %s "
         "(%s) "
         "UID=%d "
         "MNTNS_ID=%lu.\n",
         syscall_name, e->pid, e->comm, container_id, container_type, e->uid,
         e->mntns_id);
  return 0;
}

int main(int argc, char *argv[]) {

  // using bpf program skeleton generated by bpftool.
  struct syscall_blocker_bpf *skel;
  int err;
  struct Configuration config = {
      .count_mntns = 0, .count_syscalls = 0, .count_uids = 0};
  struct ring_buffer *rb;

  // parse command line arguments
  char syscall_names[MAX_ENTRIES][30];
  bool traceonly = false;

  if ((argc >= 2) && (strcmp(argv[1], "--help") == 0)) {
    print_help(argv[0]);
    exit(0);
  }

  for (int next_arg = 1; (next_arg < argc) && (*argv[next_arg] == '-');
       next_arg += 1) {
    if (strcmp(argv[next_arg], "--help") == 0) {
      print_help(argv[0]);
      exit(0);
    } else if (strcmp(argv[next_arg], "--users") == 0) {
      if (next_arg == (argc - 1)) {
        printf("No value provided for %s option\n", argv[next_arg]);
        exit(1);
      }
      if (config.count_uids >= MAX_ENTRIES) {
        printf("no. of user is more than limit.\n");
        exit(1);
      }
      next_arg++;
      while (next_arg < argc && argv[next_arg][0] != '-') {

        config.uids[config.count_uids++] = get_long(
            argv[next_arg], "Bad user_id %s; must be a positive integer\n");
        next_arg++;
      }
      next_arg--;
    } else if (strcmp(argv[next_arg], "--mntnss") == 0) {
      if (next_arg == (argc - 1)) {
        printf("No value provided for %s option\n", argv[next_arg]);
        exit(1);
      }
      if (config.count_mntns >= MAX_ENTRIES) {
        printf("no. of MNT_NS_IDs is more than limit.\n");
        exit(1);
      }
      next_arg++;
      while (next_arg < argc && argv[next_arg][0] != '-') {

        config.mntns_ids[config.count_mntns++] = get_long(
            argv[next_arg], "Bad mntns_id %s; must be a positive integer\n");
        next_arg++;
      }
      next_arg--;
    } else if (strcmp(argv[next_arg], "--syscalls") == 0) {
      if (next_arg == (argc - 1)) {
        printf("No value provided for %s option\n", argv[next_arg]);
        exit(1);
      }
      if (config.count_syscalls >= MAX_ENTRIES) {
        printf("no. of syscalls is more than limit.\n");
        exit(1);
      }
      next_arg++;

      while (next_arg < argc && argv[next_arg][0] != '-') {
        int i = config.count_syscalls++;
        get_string(syscall_names[i], argv[next_arg]);
        config.syscall_nums[i] = seccomp_syscall_resolve_name(syscall_names[i]);
        if (config.syscall_nums[i] == __NR_SCMP_ERROR) {
          printf("Bad syscall name : %s\n", syscall_names[i]);
          exit(1);
        }
        next_arg++;
      }
      next_arg--;
    } else if (strcmp(argv[next_arg], "--traceonly") == 0) {
      traceonly = true;
    }
  }

  if (config.count_mntns == 0 || config.count_syscalls == 0 ||
      config.count_uids == 0) {
    printf("Usage: %s --syscalls <syscall names> --users <UIDs> --mntnss "
           "<MNT_NS_IDs>\n",
           argv[0]);
    exit(1);
  }

  /* Open BPF skeleton application */
  skel = syscall_blocker_bpf__open();
  if (!skel) {
    fprintf(stderr, "Failed to open BPF skeleton: %s\n", strerror(errno));
    return 1;
  }

  /* Load & verify BPF programs */
  err = syscall_blocker_bpf__load(skel);
  if (err) {
    fprintf(stderr, "Failed to load and verify BPF skeleton: %s\n",
            strerror(err));
    goto cleanup;
  }

  printf("bpf program has been loaded and verified.\n");

  // Get the BPF map file descriptor to pass the configurations to ebpf program
  int map_fd = bpf_map__fd(skel->maps.block_syscall_map);
  if (map_fd < 0) {
    fprintf(stderr, "Failed to find BPF map : %s\n", strerror(errno));
    goto cleanup;
  }

  // Write the UIDs and MNT_NSs ID to the BPF map
  int key = 0;

  // pass the configurations to bpf program
  err = bpf_map_update_elem(map_fd, &key, &config, BPF_ANY);
  if (err) {
    fprintf(stderr, "Failed to update BPF map: %s\n", strerror(err));
    goto cleanup;
  }

  display_config(&config);

  // create ring buffer for tracing the events

  rb = ring_buffer__new(bpf_map__fd(skel->maps.events), handle_event, NULL,
                        NULL);
  if (!rb) {
    fprintf(stderr, "Failed to create ring buffer\n");
    goto cleanup;
  }

  /* Attach syscall_blocker ebpf program to the respective syscall*/

  if (!traceonly) {
    // Kprobe - This attaches the block_syscall program which blocks the
    // syscall to syscall.
    // x86_64 syscalls.Available kprobe functions in /proc/kallsym (__x64_sys_*)

    // attach each syscall to their respective function

    for (int i = 0; i < config.count_syscalls; i++) {
      char prefix[50] = "__x64_sys_";
      char *kprobe_func_name =
          strncat(prefix, syscall_names[i],
                  sizeof(prefix) - strlen(syscall_names[i]) - 1);

      skel->links.block_syscall = bpf_program__attach_kprobe(
          skel->progs.block_syscall, false, kprobe_func_name);
      err = (NULL == skel->links.block_syscall);
      if (err) {
        fprintf(stderr, "Failed to attach BPF skeleton: %s\n", strerror(err));
        goto cleanup;
      }
      printf(
          "eBPF kprobe program has been attached to the syscall function %s.\n",
          kprobe_func_name);
    }
  } else {
    // Tracepoint - Attach trace_syscall program which only logs the syscalls.
    // this only traces the syscalls triggered by the filtered canditates.
    // This program attaches to raw syscalls sys_enter.
    err = syscall_blocker_bpf__attach(skel);
    if (err) {
      fprintf(stderr, "Failed to attach BPF skeleton: %s\n", strerror(err));
      goto cleanup;
    }
    printf("eBPF tracepoint program has been attached to the sys_enter "
           "tracepoint");
  }

  printf("eBPF program loaded and attached.\n");
  printf("Press : k - kill container, esc -  Exit\n\n");

  // for gracefully exiting the program through signals
  signal(SIGINT, handle_signal);
  signal(SIGTERM, handle_signal);

  // Poll ring buffer and also the user inputs
  set_nonblocking_mode(1);
  char c;
  while (!stop) {
    if (read(STDIN_FILENO, &c, 1) > 0) {
      if (c == 27) { // exit through ESC
        stop = 1;
      }
      if (c == 107) {
        set_nonblocking_mode(0);
        kill_container_prompt();
        set_nonblocking_mode(1);
      }
    }
    ring_buffer__poll(rb, 100);
  }
  set_nonblocking_mode(0);
  printf("Exiting...\n");

cleanup:
  syscall_blocker_bpf__destroy(skel);
  ring_buffer__free(rb);

  return 0;
}

void print_help(const char *name) {
  printf(
      "Usage: %s --users <user ids> --mntnss <mount namspace ids> --syscalls "
      "<syscall names>\n\n"
      "Intercepts and blocks syscalls by certain users and mount namespaces using eBPF kprobes."
      "The available options :\n\n"
      "--syscalls     syscall names to intercept\n"
      "--users        user ids to filter\n"
      "--mntnss       mount namespace ids to filter\n"
      "--traceonly    attach only to tracepoint (can't block syscall) (default : false)",
      name);
}

// These are utility functions to parse arguments in cli
void get_string(char *target, char *source) {
  strncpy(target, source, sizeof(target) - 1);
  target[sizeof(target) - 1] = '\0';
}

unsigned long get_long(const char *s, const char *msg) {
  unsigned long value;
  char *end;
  value = strtol(s, &end, 10);
  if (end == s) {
    printf(msg, s);
    exit(1);
  }
  return value;
}

int get_int(const char *s, const char *msg) {
  int value;
  char *end;
  value = strtol(s, &end, 10);
  if (end == s) {
    printf(msg, s);
    exit(1);
  }
  return value;
}

/* Displays the configuration to the stdout */
void display_config(struct Configuration *config) {
  printf("Configuration written to BPF map: \n"
         "UIDs=");
  for (int i = 0; i < config->count_uids; i++) {
    printf("%lu ", config->uids[i]);
  }

  printf("\nMNT_NS_IDs=");

  for (int i = 0; i < config->count_mntns; i++) {
    printf("%lu ", config->mntns_ids[i]);
  }

  printf("\nSYSCALL_NOs=");

  for (int i = 0; i < config->count_syscalls; i++) {
    printf("%d ", config->syscall_nums[i]);
  }

  printf("\n");
}

// For polling the ring buffer without blocking user input
void set_nonblocking_mode(int enable) {
  struct termios tty;
  tcgetattr(STDIN_FILENO, &tty);

  if (enable) {
    tty.c_lflag &= ~(ICANON | ECHO); // Disable line buffering and echo
  } else {
    tty.c_lflag |= (ICANON | ECHO);
  }

  tcsetattr(STDIN_FILENO, TCSANOW, &tty);

  int flags = fcntl(STDIN_FILENO, F_GETFL, 0);
  if (enable) {
    fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK); // Set stdin non-blocking
  } else {
    fcntl(STDIN_FILENO, F_SETFL, flags & ~O_NONBLOCK);
  }
}

// For getting container id and its type by decoding cgroup_path.
void get_container_info(const char *cgroup_path, char *container_type,
                        char *container_id) {
  if (!cgroup_path || !container_type || !container_id)
    return;

  container_type[0] = '\0';
  container_id[0] = '\0';

  const char *docker_prefix = "docker-";
  char *docker_ptr = strstr(cgroup_path, docker_prefix);
  if (docker_ptr) {
    strcpy(container_type, "docker");
    strncpy(container_id, docker_ptr + strlen(docker_prefix), 12);
    container_id[12] = '\0';
    return;
  }

  const char *podman_prefix = "libpod-";
  char *podman_ptr = strstr(cgroup_path, podman_prefix);
  if (podman_ptr) {
    strcpy(container_type, "podman");
    strncpy(container_id, podman_ptr + strlen(podman_prefix), 12);
    container_id[12] = '\0'; // Ensure null termination
    return;
  }

  strncpy(container_id, cgroup_path, sizeof(container_id) - 1);
  container_id[sizeof(container_id) - 1] = '\0';
  strcpy(container_type, "unknown");
}

int command_exists(const char *cmd) {
  char path[256];
  snprintf(path, sizeof(path), "command -v %s > /dev/null 2>&1", cmd);
  return (system(path) == 0);
}

// Function to kill a container by ID and it container type
int kill_container_prompt() {
  char command[256];

  char container_id[13], container_type[10];

  printf("Enter the container id to kill: ");

  if (scanf("%12s", container_id) != 1) {
    fprintf(stderr, "Invalid input\n");
    return 1;
  }

  printf("Enter the container type (docker or podman): ");
  scanf("%s", container_type);

  if (strcmp(container_type, "docker") == 0) {
    if (command_exists("docker")) {
      snprintf(command, sizeof(command), "docker kill %s", container_id);
    } else {
      fprintf(stderr, "Docker cli is no installed.\n");
      return -1;
    }
  }

  else if (strcmp(container_type, "podman") == 0) {
    if (command_exists("podman")) {
      snprintf(command, sizeof(command), "podman kill %s", container_id);
    } else {
      fprintf(stderr, "Podman cli is not installed.\n");
      return -1;
    }
  }

  int result = system(command);
  if (result == 0) {
    printf("Killed container %s\n", container_id);
    return 0;
  } else {
    fprintf(stderr, "Failed to kill container %s\n", container_id);
    return -1;
  }
}