// filepath: /sys-call-blocker/src/syscall_blocker.bpf.c

// trace logs : $ sudo cat /sys/kernel/debug/tracing/trace_pipe

#include "syscall_blocker.h"
#include <bpf/bpf.h>
#include <bpf/libbpf.h>
#include <errno.h>
#include <seccomp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>

/* // generated by bpftool in build directory. if not exist, build the project
// to generate it */
#include "syscall_blocker.skel.h"

void print_help(const char *name);
int get_int(const char *s, const char *msg);
unsigned long get_long(const char *s, const char *msg);
void get_string(char *target, char *source);
void display_config(struct Configuration *config);

int main(int argc, char *argv[]) {

  // using bpf program skeleton generated by bpftool.
  struct syscall_blocker_bpf *skel;
  int err;
  struct Configuration config = {
      .count_mntns = 0, .count_syscalls = 0, .count_uids = 0};

  // parse command line arguments
  // int count_uids = 0, count_mntns_ids = 0, count_syscalls = 0;
  // find uid by "id -u"
  // find mntns_id by "stat -L -c %i /proc/self/ns/mnt"
  // unsigned long user_ids[MAX_ENTRIES], mntns_ids[MAX_ENTRIES];
  char syscall_names[MAX_ENTRIES][30];
  // int syscall_nums[MAX_ENTRIES];
  bool traceonly = false;

  if ((argc >= 2) && (strcmp(argv[1], "--help") == 0)) {
    print_help(argv[0]);
    exit(0);
  }

  for (int next_arg = 1; (next_arg < argc) && (*argv[next_arg] == '-');
       next_arg += 1) {        
    if (strcmp(argv[next_arg], "--help") == 0) {
      print_help(argv[0]);
      exit(0);
    } else if (strcmp(argv[next_arg], "--users") == 0) {
      if (next_arg == (argc - 1)) {
        printf("No value provided for %s option\n", argv[next_arg]);
        exit(1);
      }
      if(config.count_uids >= MAX_ENTRIES){
        printf("no. of user is more than limit.\n");
        exit(1);
      }
      next_arg++;
      while (next_arg < argc && argv[next_arg][0] != '-') {

        config.uids[config.count_uids++] = get_long(
            argv[next_arg], "Bad user_id %s; must be a positive integer\n");
        next_arg++;
      }
      next_arg--;
    } else if (strcmp(argv[next_arg], "--mntnss") == 0) {
      if (next_arg == (argc - 1)) {
        printf("No value provided for %s option\n", argv[next_arg]);
        exit(1);
      }
      if(config.count_mntns >= MAX_ENTRIES){
        printf("no. of MNT_NS_IDs is more than limit.\n");
        exit(1);
      }
      next_arg++;
      while (next_arg < argc && argv[next_arg][0] != '-') {

        config.mntns_ids[config.count_mntns++] = get_long(
            argv[next_arg], "Bad mntns_id %s; must be a positive integer\n");
        next_arg++;
      }
      next_arg--;
    } else if (strcmp(argv[next_arg], "--syscalls") == 0) {
      if (next_arg == (argc - 1)) {
        printf("No value provided for %s option\n", argv[next_arg]);
        exit(1);
      }
      if(config.count_syscalls >= MAX_ENTRIES){
        printf("no. of syscalls is more than limit.\n");
        exit(1);
      }
      next_arg++;

      while (next_arg < argc && argv[next_arg][0] != '-') {
        int i = config.count_syscalls++;
        get_string(syscall_names[i], argv[next_arg]);
        config.syscall_nums[i] = seccomp_syscall_resolve_name(syscall_names[i]);
        if (config.syscall_nums[i] == __NR_SCMP_ERROR) {
          printf("Bad syscall name : %s\n", syscall_names[i]);
          exit(1);
        }
        next_arg++;
      }
      next_arg--;
    } else if (strcmp(argv[next_arg], "--traceonly") == 0) {
      traceonly = true;
    }
  }


  if (config.count_mntns == 0 || config.count_syscalls == 0 ||
      config.count_uids == 0) {
    printf("Usage: %s --syscalls <syscall names> --users <UIDs> --mntnss "
           "<MNT_NS_IDs>\n",
           argv[0]);
    exit(1);
  }

  /* Open BPF skeleton application */
  skel = syscall_blocker_bpf__open();
  if (!skel) {
    fprintf(stderr, "Failed to open BPF skeleton: %s\n", strerror(errno));
    return 1;
  }

  /* Load & verify BPF programs */
  err = syscall_blocker_bpf__load(skel);
  if (err) {
    fprintf(stderr, "Failed to load and verify BPF skeleton: %s\n",
            strerror(err));
    goto cleanup;
  }

  printf("bpf program has been loaded and verified.\n");

  // Get the BPF map file descriptor to pass the configurations to ebpf program
  int map_fd = bpf_map__fd(skel->maps.block_syscall_map);
  if (map_fd < 0) {
    fprintf(stderr, "Failed to find BPF map : %s\n", strerror(errno));
    goto cleanup;
  }

  // Write the UIDs and MNT_NSs ID to the BPF map
  int key = 0;

  // pass the configurations to bpf program
  err = bpf_map_update_elem(map_fd, &key, &config, BPF_ANY);
  if (err) {
    fprintf(stderr, "Failed to update BPF map: %s\n", strerror(err));
    goto cleanup;
  }

  display_config(&config);
  /* Attach syscall_blocker ebpf program to the respective syscall*/

  if (!traceonly) {
    // Kprobe - This attaches the block_syscall program which blocks the
    // syscall to syscall.
    // x86_64 syscalls.Available kprobe functions in /proc/kallsym (__x64_sys_*)

    // attach each syscall to their respective function

    for (int i = 0; i < config.count_syscalls; i++) {
      char prefix[50] = "__x64_sys_";
      char *kprobe_func_name =
          strncat(prefix, syscall_names[i],
                  sizeof(prefix) - strlen(syscall_names[i]) - 1);

      skel->links.block_syscall = bpf_program__attach_kprobe(
          skel->progs.block_syscall, false, kprobe_func_name);
      err = (NULL == skel->links.block_syscall);
      if (err) {
        fprintf(stderr, "Failed to attach BPF skeleton: %s\n", strerror(err));
        goto cleanup;
      }
      printf(
          "eBPF kprobe program has been attached to the syscall function %s.\n",
          kprobe_func_name);
    }
  } else {
    // Tracepoint - Attach trace_syscall program which only logs the syscalls.
    // this only traces the syscalls triggered by the filtered canditates.
    // This program attaches to raw syscalls sys_enter.
    err = syscall_blocker_bpf__attach(skel);
    if (err) {
      fprintf(stderr, "Failed to attach BPF skeleton: %s\n", strerror(err));
      goto cleanup;
    }
    printf("eBPF tracepoint program has been attached to the sys_enter "
           "tracepoint");
  }

  printf("eBPF program loaded and attached. Press Enter to exit...\n");
  getchar();

cleanup:
  syscall_blocker_bpf__destroy(skel);

  return 0;
}

void print_help(const char *name) {
  printf(
      "Usage: %s --users <user ids> --mntnss <mount namspace ids> --syscalls "
      "<syscall names>\n\n"
      "blocks system calls"
      "The available options :\n\n"
      "--syscalls     syscall name to intercept\n"
      "--users        user id to filter\n"
      "--mntnss       mount namespace ids to filter (default: IPv4)\n"
      "--traceonly    attach only tracepoint (can't block syscall)",
      name);
}

void get_string(char *target, char *source) {
  strncpy(target, source, sizeof(target) - 1);
  target[sizeof(target) - 1] = '\0';
}

unsigned long get_long(const char *s, const char *msg) {
  unsigned long value;
  char *end;
  value = strtol(s, &end, 10);
  if (end == s) {
    printf(msg, s);
    exit(1);
  }
  return value;
}

int get_int(const char *s, const char *msg) {
  int value;
  char *end;
  value = strtol(s, &end, 10);
  if (end == s) {
    printf(msg, s);
    exit(1);
  }
  return value;
}

void display_config(struct Configuration *config) {
  printf("Configuration written to BPF map: \n"
         "UIDs=");
  for (int i = 0; i < config->count_uids; i++) {
    printf("%lu ", config->uids[i]);
  }

  printf("\nMNT_NS_IDs=");

  for (int i = 0; i < config->count_mntns; i++) {
    printf("%lu ", config->mntns_ids[i]);
  }

  printf("\nSYSCALL_NOs=");

  for (int i = 0; i < config->count_syscalls; i++) {
    printf("%d ", config->syscall_nums[i]);
  }

  printf("\n");
}